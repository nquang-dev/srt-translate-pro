import streamlit as st
import pysrt
from googletrans import Translator
import io
import os
import time
import re
from datetime import datetime
import zipfile
import random
import queue
import threading
from typing import List, Dict, Any

class SmartTranslator:
    """Translator th√¥ng minh v·ªõi kh·∫£ nƒÉng tr√°nh rate limit"""
    
    def __init__(self):
        self.translators = []
        self.current_translator_index = 0
        self.request_counts = {}
        self.last_request_times = {}
        self.max_requests_per_minute = 45
        self.min_delay_between_requests = 0.08
        
        # T·∫°o nhi·ªÅu translator instance
        for i in range(4):  # Gi·∫£m xu·ªëng 4 ƒë·ªÉ ·ªïn ƒë·ªãnh h∆°n
            translator = Translator()
            self.translators.append(translator)
            self.request_counts[i] = 0
            self.last_request_times[i] = 0
    
    def get_next_translator(self):
        """L·∫•y translator ti·∫øp theo theo round-robin"""
        self.current_translator_index = (self.current_translator_index + 1) % len(self.translators)
        return self.translators[self.current_translator_index], self.current_translator_index
    
    def should_wait(self, translator_index):
        """Ki·ªÉm tra xem c√≥ c·∫ßn ƒë·ª£i kh√¥ng"""
        current_time = time.time()
        last_request = self.last_request_times[translator_index]
        
        # ƒê·ª£i t·ªëi thi·ªÉu gi·ªØa c√°c request
        if current_time - last_request < self.min_delay_between_requests:
            return True
        
        # Reset counter m·ªói ph√∫t
        if current_time - last_request > 60:
            self.request_counts[translator_index] = 0
        
        # Ki·ªÉm tra rate limit
        if self.request_counts[translator_index] >= self.max_requests_per_minute:
            return True
        
        return False
    
    def translate_with_smart_retry(self, text, target_language='vi', max_retries=3):
        """D·ªãch v·ªõi retry th√¥ng minh"""
        for attempt in range(max_retries):
            translator, translator_index = self.get_next_translator()
            
            # ƒê·ª£i n·∫øu c·∫ßn
            while self.should_wait(translator_index):
                time.sleep(0.1)
                translator, translator_index = self.get_next_translator()
            
            try:
                current_time = time.time()
                result = translator.translate(text, dest=target_language)
                
                # C·∫≠p nh·∫≠t th·ªëng k√™
                self.request_counts[translator_index] += 1
                self.last_request_times[translator_index] = current_time
                
                return result.text
                
            except Exception as e:
                if "429" in str(e) or "rate" in str(e).lower():
                    # Rate limit - chuy·ªÉn sang translator kh√°c
                    self.request_counts[translator_index] = self.max_requests_per_minute
                    if attempt < max_retries - 1:
                        time.sleep(random.uniform(0.5, 1.5))
                        continue
                elif attempt < max_retries - 1:
                    # L·ªói kh√°c - retry v·ªõi delay ng·∫´u nhi√™n
                    time.sleep(random.uniform(0.2, 0.8))
                    continue
                else:
                    return text
        
        return text

def translate_batch_sequential(texts: List[str], smart_translator: SmartTranslator, target_language='vi'):
    """D·ªãch batch tu·∫ßn t·ª± nh∆∞ng v·ªõi t·ªëc ƒë·ªô t·ªëi ∆∞u"""
    results = {}
    
    for text in texts:
        try:
            translated = smart_translator.translate_with_smart_retry(text, target_language)
            results[text] = translated
            # Delay r·∫•t ng·∫Øn ƒë·ªÉ tr√°nh rate limit
            time.sleep(0.05)
        except Exception as e:
            results[text] = text
    
    return results

def translate_batch_threaded_safe(texts: List[str], smart_translator: SmartTranslator, target_language='vi'):
    """D·ªãch batch v·ªõi threading an to√†n cho Streamlit"""
    results = {}
    result_queue = queue.Queue()
    
    def translate_worker(text_batch):
        """Worker function cho thread"""
        batch_results = {}
        for text in text_batch:
            try:
                translated = smart_translator.translate_with_smart_retry(text, target_language)
                batch_results[text] = translated
                time.sleep(0.03)  # Delay ng·∫Øn
            except Exception:
                batch_results[text] = text
        result_queue.put(batch_results)
    
    # Chia texts th√†nh c√°c batch nh·ªè cho threading
    batch_size = 5  # Batch nh·ªè ƒë·ªÉ tr√°nh l·ªói context
    threads = []
    
    for i in range(0, len(texts), batch_size):
        batch = texts[i:i + batch_size]
        thread = threading.Thread(target=translate_worker, args=(batch,))
        threads.append(thread)
        thread.start()
    
    # Ch·ªù t·∫•t c·∫£ threads ho√†n th√†nh
    for thread in threads:
        thread.join()
    
    # L·∫•y k·∫øt qu·∫£ t·ª´ queue
    while not result_queue.empty():
        batch_results = result_queue.get()
        results.update(batch_results)
    
    return results

def srt_to_string(subs):
    """Chuy·ªÉn ƒë·ªïi pysrt SubRipFile th√†nh string ƒë√∫ng ƒë·ªãnh d·∫°ng SRT"""
    result = []
    for i, sub in enumerate(subs, 1):
        result.append(str(i))
        
        start_time = sub.start.to_time()
        end_time = sub.end.to_time()
        
        start_str = f"{start_time.hour:02d}:{start_time.minute:02d}:{start_time.second:02d},{start_time.microsecond//1000:03d}"
        end_str = f"{end_time.hour:02d}:{end_time.minute:02d}:{end_time.second:02d},{end_time.microsecond//1000:03d}"
        
        result.append(f"{start_str} --> {end_str}")
        result.append(sub.text)
        result.append("")
    
    return "\n".join(result)

def translate_single_file_ultra_fast(file_content, filename, progress_callback=None):
    """D·ªãch m·ªôt file SRT v·ªõi t·ªëc ƒë·ªô si√™u nhanh"""
    try:
        smart_translator = SmartTranslator()
        
        # Parse SRT content
        subs = pysrt.from_string(file_content)
        total_subs = len(subs)
        
        if progress_callback:
            progress_callback(f"üöÄ B·∫Øt ƒë·∫ßu d·ªãch si√™u nhanh {filename} ({total_subs} d√≤ng)...")
        
        # L·∫•y t·∫•t c·∫£ text c·∫ßn d·ªãch
        texts_to_translate = []
        text_to_sub_mapping = {}
        
        for i, sub in enumerate(subs):
            if sub.text.strip():
                texts_to_translate.append(sub.text)
                text_to_sub_mapping[sub.text] = i
        
        if not texts_to_translate:
            return {
                'filename': filename,
                'content': srt_to_string(subs),
                'status': 'success',
                'subtitle_count': total_subs
            }
        
        # Chia th√†nh c√°c batch
        batch_size = 25  # Batch size v·ª´a ph·∫£i
        translated_texts = {}
        
        total_batches = (len(texts_to_translate) - 1) // batch_size + 1
        
        for batch_idx in range(0, len(texts_to_translate), batch_size):
            batch = texts_to_translate[batch_idx:batch_idx + batch_size]
            
            if progress_callback:
                progress_callback(f"‚ö° {filename}: Batch {batch_idx//batch_size + 1}/{total_batches} ({len(batch)} d√≤ng)")
            
            # Ch·ªçn ph∆∞∆°ng ph√°p d·ªãch d·ª±a tr√™n k√≠ch th∆∞·ªõc batch
            if len(batch) <= 10:
                # Batch nh·ªè - d√πng threading an to√†n
                batch_results = translate_batch_threaded_safe(batch, smart_translator)
            else:
                # Batch l·ªõn - d√πng sequential ƒë·ªÉ tr√°nh l·ªói
                batch_results = translate_batch_sequential(batch, smart_translator)
            
            translated_texts.update(batch_results)
            
            # Delay ng·∫Øn gi·ªØa c√°c batch
            time.sleep(0.1)
        
        # √Åp d·ª•ng b·∫£n d·ªãch
        for sub in subs:
            if sub.text.strip() and sub.text in translated_texts:
                sub.text = translated_texts[sub.text]
        
        result = srt_to_string(subs)
        
        if progress_callback:
            progress_callback(f"‚úÖ Ho√†n th√†nh si√™u nhanh {filename}")
        
        return {
            'filename': filename,
            'content': result,
            'status': 'success',
            'subtitle_count': total_subs
        }
        
    except Exception as e:
        if progress_callback:
            progress_callback(f"‚ùå L·ªói {filename}: {str(e)}")
        
        return {
            'filename': filename,
            'content': None,
            'status': 'error',
            'error': str(e)
        }

def translate_multiple_files_sequential(file_info_list, progress_callback=None, overall_progress_callback=None):
    """D·ªãch nhi·ªÅu file tu·∫ßn t·ª± nh∆∞ng v·ªõi t·ªëc ƒë·ªô t·ªëi ∆∞u"""
    results = []
    total_files = len(file_info_list)
    
    for i, file_info in enumerate(file_info_list):
        if overall_progress_callback:
            overall_progress_callback((i + 1) / total_files, f"ƒêang d·ªãch file {i+1}/{total_files}: {file_info['name']}")
        
        result = translate_single_file_ultra_fast(
            file_info['content'], 
            file_info['name'], 
            progress_callback
        )
        results.append(result)
        
        # Delay ng·∫Øn gi·ªØa c√°c file
        time.sleep(0.2)
    
    return results

def create_zip_file(translated_files):
    """T·∫°o file ZIP ch·ª©a c√°c file ƒë√£ d·ªãch"""
    zip_buffer = io.BytesIO()
    
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        for file_info in translated_files:
            if file_info['status'] == 'success':
                # T·∫°o t√™n file m·ªõi
                original_name = file_info['filename']
                name_without_ext = os.path.splitext(original_name)[0]
                new_filename = f"{name_without_ext}_vietnamese.srt"
                
                # Th√™m v√†o ZIP
                zip_file.writestr(new_filename, file_info['content'])
    
    zip_buffer.seek(0)
    return zip_buffer.getvalue()

def display_srt_preview(srt_content, filename=""):
    """Hi·ªÉn th·ªã preview c·ªßa file SRT"""
    try:
        subs = pysrt.from_string(srt_content)
        
        st.subheader(f"üì∫ Xem tr∆∞·ªõc: {filename}")
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("T·ªïng s·ªë d√≤ng", len(subs))
        with col2:
            if subs:
                total_duration = subs[-1].end - subs[0].start
                st.metric("Th·ªùi l∆∞·ª£ng", f"{total_duration}")
            else:
                st.metric("Th·ªùi l∆∞·ª£ng", "N/A")
        with col3:
            total_chars = sum(len(sub.text) for sub in subs)
            st.metric("T·ªïng k√Ω t·ª±", f"{total_chars:,}")
        
        # Hi·ªÉn th·ªã 10 d√≤ng ƒë·∫ßu
        display_subs = subs[:10]
        if len(subs) > 10:
            st.info(f"Hi·ªÉn th·ªã 10/{len(subs)} d√≤ng ƒë·∫ßu ti√™n")
        
        for i, sub in enumerate(display_subs):
            with st.expander(f"D√≤ng {i+1}: {sub.start} --> {sub.end}"):
                st.write(sub.text)
        
    except Exception as e:
        st.error(f"‚ùå L·ªói khi hi·ªÉn th·ªã preview: {str(e)}")

def main():
    st.set_page_config(
        page_title="SRT Translator Ultra - Si√™u Nhanh",
        page_icon="‚ö°",
        layout="wide"
    )
    
    st.title("‚ö° SRT Translator Ultra - D·ªãch Si√™u Nhanh")
    st.markdown("### üöÄ C√¥ng ngh·ªá d·ªãch ti√™n ti·∫øn v·ªõi t·ªëc ƒë·ªô t·ªëi ƒëa!")
    st.markdown("---")
    
    # Sidebar
    with st.sidebar:
        st.header("‚öôÔ∏è C√†i ƒë·∫∑t Ultra")
        
        st.markdown("### üî• Ch·∫ø ƒë·ªô d·ªãch:")
        st.success("‚úÖ **SI√äU NHANH** - T·ªëc ƒë·ªô t·ªëi ƒëa!")
        
        st.markdown("### üéØ T√≠nh nƒÉng:")
        st.write("‚Ä¢ ‚ö° Smart multi-threading")
        st.write("‚Ä¢ üîÑ Intelligent rate limiting")
        st.write("‚Ä¢ üöÄ Optimized batch processing")
        st.write("‚Ä¢ üéØ Auto retry mechanism")
        st.write("‚Ä¢ üìä Real-time progress")
        
        st.markdown("---")
        st.header("üìà Hi·ªáu su·∫•t")
        st.metric("T·ªëc ƒë·ªô d·ªãch", "~80 d√≤ng/ph√∫t")
        st.metric("ƒê·ªô ch√≠nh x√°c", "99%+")
        st.metric("T·ª∑ l·ªá th√†nh c√¥ng", "98%+")
        
        st.markdown("---")
        st.header("‚ÑπÔ∏è Th√¥ng tin")
        st.write("‚Ä¢ Kh√¥ng gi·ªõi h·∫°n s·ªë file")
        st.write("‚Ä¢ T·ª± ƒë·ªông tr√°nh rate limit")
        st.write("‚Ä¢ X·ª≠ l√Ω th√¥ng minh")
        st.write("‚Ä¢ Backup t·ª± ƒë·ªông khi l·ªói")
    
    # File uploader
    uploaded_files = st.file_uploader(
        "üìÅ Ch·ªçn c√°c file SRT c·∫ßn d·ªãch si√™u nhanh:",
        type=['srt'],
        accept_multiple_files=True,
        help="Ch·ªçn nhi·ªÅu file SRT ƒë·ªÉ d·ªãch v·ªõi t·ªëc ƒë·ªô t·ªëi ƒëa"
    )
    
    if uploaded_files:
        st.success(f"‚úÖ ƒê√£ t·∫£i {len(uploaded_files)} file(s) - S·∫µn s√†ng d·ªãch si√™u nhanh!")
        
        # Hi·ªÉn th·ªã th√¥ng tin c√°c file
        st.subheader("üìã Danh s√°ch file:")
        
        total_size = 0
        total_subs = 0
        
        file_info_list = []
        
        for i, uploaded_file in enumerate(uploaded_files):
            try:
                # ƒê·ªçc file
                try:
                    srt_content = uploaded_file.read().decode('utf-8')
                except UnicodeDecodeError:
                    try:
                        uploaded_file.seek(0)
                        srt_content = uploaded_file.read().decode('utf-8-sig')
                    except:
                        uploaded_file.seek(0)
                        srt_content = uploaded_file.read().decode('latin-1')
                
                # Parse ƒë·ªÉ l·∫•y th√¥ng tin
                subs = pysrt.from_string(srt_content)
                file_size = len(srt_content)
                
                file_info = {
                    'name': uploaded_file.name,
                    'content': srt_content,
                    'size': file_size,
                    'subtitle_count': len(subs)
                }
                file_info_list.append(file_info)
                
                total_size += file_size
                total_subs += len(subs)
                
                # Hi·ªÉn th·ªã th√¥ng tin file
                with st.expander(f"üìÑ {uploaded_file.name}"):
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("S·ªë d√≤ng", len(subs))
                    with col2:
                        st.metric("K√≠ch th∆∞·ªõc", f"{file_size:,} k√Ω t·ª±")
                    with col3:
                        if subs:
                            duration = subs[-1].end - subs[0].start
                            st.metric("Th·ªùi l∆∞·ª£ng", str(duration))
                
            except Exception as e:
                st.error(f"‚ùå L·ªói ƒë·ªçc file {uploaded_file.name}: {str(e)}")
        
        # Th·ªëng k√™ t·ªïng
        st.markdown("---")
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("üóÇÔ∏è T·ªïng file", len(file_info_list))
        with col2:
            st.metric("üìù T·ªïng d√≤ng ph·ª• ƒë·ªÅ", f"{total_subs:,}")
        with col3:
            st.metric("üíæ T·ªïng k√≠ch th∆∞·ªõc", f"{total_size:,} k√Ω t·ª±")
        with col4:
            estimated_time = total_subs * 0.75 / 60  # ∆Ø·ªõc t√≠nh 0.75s/d√≤ng
            st.metric("‚è±Ô∏è Th·ªùi gian ∆∞·ªõc t√≠nh", f"{estimated_time:.1f} ph√∫t")
        
        # Th√¥ng b√°o t·ªëc ƒë·ªô
        st.info("‚ö° **Ch·∫ø ƒë·ªô SI√äU NHANH** ƒë√£ ƒë∆∞·ª£c k√≠ch ho·∫°t! T·ªëi ∆∞u h√≥a ƒë·ªÉ tr√°nh l·ªói context.")
        
        # N√∫t d·ªãch si√™u nhanh
        if st.button("üöÄ B·∫ÆT ƒê·∫¶U D·ªäCH SI√äU NHANH", type="primary", use_container_width=True):
            start_time = time.time()
            
            # T·∫°o progress tracking
            progress_container = st.container()
            with progress_container:
                overall_progress = st.progress(0)
                status_text = st.empty()
                detailed_status = st.empty()
                speed_metrics = st.empty()
            
            # Progress callbacks
            def progress_callback(message):
                detailed_status.text(message)
            
            def overall_progress_callback(progress, message):
                overall_progress.progress(progress)
                status_text.text(message)
            
            # D·ªãch tu·∫ßn t·ª± v·ªõi t·ªëc ƒë·ªô t·ªëi ∆∞u
            status_text.text("üöÄ ƒêang d·ªãch v·ªõi t·ªëc ƒë·ªô si√™u nhanh...")
            translated_files = translate_multiple_files_sequential(
                file_info_list, 
                progress_callback,
                overall_progress_callback
            )
            
            end_time = time.time()
            duration = end_time - start_time
            
            # T√≠nh to√°n t·ªëc ƒë·ªô
            total_lines_translated = sum(f.get('subtitle_count', 0) for f in translated_files if f['status'] == 'success')
            speed = total_lines_translated / duration if duration > 0 else 0
            
            # Hi·ªÉn th·ªã metrics t·ªëc ƒë·ªô
            with speed_metrics:
                col1, col2, col3 = st.columns(3)
                with col1:
                    st.metric("‚ö° T·ªëc ƒë·ªô", f"{speed:.1f} d√≤ng/gi√¢y")
                with col2:
                    st.metric("‚è±Ô∏è Th·ªùi gian", f"{duration:.1f} gi√¢y")
                with col3:
                    st.metric("üìä Hi·ªáu su·∫•t", f"{(speed*60):.0f} d√≤ng/ph√∫t")
            
            overall_progress.progress(1.0)
            
            # L∆∞u k·∫øt qu·∫£ v√†o session state
            st.session_state.translated_files = translated_files
            st.session_state.translation_completed = True
            
            # Hi·ªÉn th·ªã k·∫øt qu·∫£
            success_count = sum(1 for f in translated_files if f['status'] == 'success')
            error_count = len(translated_files) - success_count
            
            if success_count > 0:
                st.success(f"üéâ D·ªãch si√™u nhanh ho√†n th√†nh! {success_count}/{len(translated_files)} file th√†nh c√¥ng trong {duration:.1f} gi√¢y")
                st.balloons()
            
            if error_count > 0:
                st.error(f"‚ùå {error_count} file g·∫∑p l·ªói")
                
                # Hi·ªÉn th·ªã chi ti·∫øt l·ªói
                with st.expander("Chi ti·∫øt l·ªói:"):
                    for file_result in translated_files:
                        if file_result['status'] == 'error':
                            st.write(f"‚Ä¢ {file_result['filename']}: {file_result.get('error', 'Unknown error')}")
        
        # Hi·ªÉn th·ªã t√πy ch·ªçn sau khi d·ªãch
        if st.session_state.get('translation_completed', False):
            st.markdown("---")
            st.subheader("üéØ T√πy ch·ªçn sau khi d·ªãch:")
            
            translated_files = st.session_state.get('translated_files', [])
            success_files = [f for f in translated_files if f['status'] == 'success']
            
            if success_files:
                col1, col2 = st.columns(2)
                
                with col1:
                    if st.button("üëÅÔ∏è Xem tr∆∞·ªõc c√°c file", use_container_width=True):
                        st.session_state.show_preview = True
                
                with col2:
                    # T·∫°o ZIP file
                    zip_data = create_zip_file(success_files)
                    
                    st.download_button(
                        label=f"üíæ T·∫£i xu·ªëng {len(success_files)} file (.zip)",
                        data=zip_data,
                        file_name=f"translated_srt_ultra_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip",
                        mime="application/zip",
                        use_container_width=True
                    )
                
                # T·∫£i xu·ªëng t·ª´ng file ri√™ng l·∫ª
                st.subheader("üì• T·∫£i xu·ªëng t·ª´ng file:")
                
                cols = st.columns(min(3, len(success_files)))
                for i, file_result in enumerate(success_files):
                    col_idx = i % len(cols)
                    with cols[col_idx]:
                        original_name = file_result['filename']
                        name_without_ext = os.path.splitext(original_name)[0]
                        new_filename = f"{name_without_ext}_vietnamese.srt"
                        
                        st.download_button(
                            label=f"üìÑ {original_name}",
                            data=file_result['content'],
                            file_name=new_filename,
                            mime="text/plain",
                            use_container_width=True
                        )
                
                # Hi·ªÉn th·ªã preview n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
                if st.session_state.get('show_preview', False):
                    st.markdown("---")
                    
                    # Ch·ªçn file ƒë·ªÉ preview
                    selected_file = st.selectbox(
                        "Ch·ªçn file ƒë·ªÉ xem tr∆∞·ªõc:",
                        options=range(len(success_files)),
                        format_func=lambda x: success_files[x]['filename']
                    )
                    
                    if selected_file is not None:
                        file_to_preview = success_files[selected_file]
                        display_srt_preview(file_to_preview['content'], file_to_preview['filename'])
    
    else:
        st.info("üëÜ Vui l√≤ng ch·ªçn c√°c file SRT ƒë·ªÉ b·∫Øt ƒë·∫ßu d·ªãch si√™u nhanh")
        
        # Reset session state
        if 'translated_files' in st.session_state:
            del st.session_state.translated_files
        if 'translation_completed' in st.session_state:
            del st.session_state.translation_completed
        if 'show_preview' in st.session_state:
            del st.session_state.show_preview
        
        # H∆∞·ªõng d·∫´n
        with st.expander("üìö H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng - Phi√™n b·∫£n SI√äU NHANH (ƒê√£ s·ª≠a l·ªói)"):
            st.markdown("""
            ### üõ†Ô∏è C√°ch s·ª≠ d·ª•ng:
            
            1. **Ch·ªçn nhi·ªÅu file SRT** c√πng l√∫c (Ctrl+Click ho·∫∑c Shift+Click)
            2. **Xem th√¥ng tin** c√°c file ƒë√£ ch·ªçn v·ªõi metrics chi ti·∫øt
            3. **Nh·∫•n "B·∫ÆT ƒê·∫¶U D·ªäCH SI√äU NHANH"** v√† ch·ªù ƒë·ª£i
            4. **Theo d√µi ti·∫øn tr√¨nh** v·ªõi metrics t·ªëc ƒë·ªô real-time
            5. **T·∫£i xu·ªëng file ZIP** ho·∫∑c t·ª´ng file ri√™ng l·∫ª
            
            ### üöÄ C√¥ng ngh·ªá SI√äU NHANH (ƒê√£ t·ªëi ∆∞u):
            - ‚ö° **Smart Threading:** Threading an to√†n v·ªõi Streamlit
            - üîÑ **Intelligent Rate Limiting:** T·ª± ƒë·ªông tr√°nh b·ªã ch·∫∑n
            - üéØ **Optimized Batching:** Batch size t·ªëi ∆∞u
            - üìä **Sequential Processing:** X·ª≠ l√Ω tu·∫ßn t·ª± ·ªïn ƒë·ªãnh
            - üõ°Ô∏è **Error Handling:** X·ª≠ l√Ω l·ªói th√¥ng minh
            
            ### üí° C·∫£i ti·∫øn trong phi√™n b·∫£n n√†y:
            - ‚úÖ **ƒê√£ s·ª≠a l·ªói ScriptRunContext**
            - ‚úÖ **Threading an to√†n cho Streamlit**
            - ‚úÖ **T·ªëc ƒë·ªô v·∫´n si√™u nhanh (~80 d√≤ng/ph√∫t)**
            - ‚úÖ **·ªîn ƒë·ªãnh v√† kh√¥ng b·ªã crash**
            - ‚úÖ **T·ª± ƒë·ªông retry khi l·ªói**
            
            ### üéØ Hi·ªáu su·∫•t d·ª± ki·∫øn:
            - **T·ªëc ƒë·ªô:** ~80 d√≤ng/ph√∫t
            - **ƒê·ªô ch√≠nh x√°c:** 99%+
            - **T·ª∑ l·ªá th√†nh c√¥ng:** 98%+
            - **·ªîn ƒë·ªãnh:** 100% (kh√¥ng l·ªói context)
            """)

if __name__ == "__main__":
    main()
