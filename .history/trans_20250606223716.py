import streamlit as st
import pysrt
from googletrans import Translator
import io
import os
import time
import re
from datetime import datetime
import zipfile
from concurrent.futures import ThreadPoolExecutor, as_completed
import threading

def split_text_into_chunks(text, max_length=4000):
    """Chia text th√†nh c√°c chunk nh·ªè h∆°n max_length"""
    if len(text) <= max_length:
        return [text]
    
    chunks = []
    sentences = re.split(r'(?<=[.!?])\s+', text)
    current_chunk = ""
    
    for sentence in sentences:
        if len(current_chunk + sentence) <= max_length:
            current_chunk += sentence + " "
        else:
            if current_chunk:
                chunks.append(current_chunk.strip())
            current_chunk = sentence + " "
    
    if current_chunk:
        chunks.append(current_chunk.strip())
    
    return chunks

def translate_text_with_retry(translator, text, target_language='vi', max_retries=3):
    """D·ªãch text v·ªõi retry mechanism"""
    for attempt in range(max_retries):
        try:
            result = translator.translate(text, dest=target_language)
            return result.text
        except Exception as e:
            if attempt < max_retries - 1:
                wait_time = (attempt + 1) * 2
                time.sleep(wait_time)
            else:
                return text

def srt_to_string(subs):
    """Chuy·ªÉn ƒë·ªïi pysrt SubRipFile th√†nh string ƒë√∫ng ƒë·ªãnh d·∫°ng SRT"""
    result = []
    for i, sub in enumerate(subs, 1):
        result.append(str(i))
        
        start_time = sub.start.to_time()
        end_time = sub.end.to_time()
        
        start_str = f"{start_time.hour:02d}:{start_time.minute:02d}:{start_time.second:02d},{start_time.microsecond//1000:03d}"
        end_str = f"{end_time.hour:02d}:{end_time.minute:02d}:{end_time.second:02d},{end_time.microsecond//1000:03d}"
        
        result.append(f"{start_str} --> {end_str}")
        result.append(sub.text)
        result.append("")
    
    return "\n".join(result)

def translate_single_file(file_content, filename, translation_method, progress_callback=None):
    """D·ªãch m·ªôt file SRT"""
    try:
        translator = Translator()
        
        # Parse SRT content
        subs = pysrt.from_string(file_content)
        total_subs = len(subs)
        
        if progress_callback:
            progress_callback(f"üîÑ B·∫Øt ƒë·∫ßu d·ªãch {filename} ({total_subs} d√≤ng)...")
        
        if translation_method == "An to√†n (t·ª´ng d√≤ng)":
            # D·ªãch t·ª´ng d√≤ng
            for i, sub in enumerate(subs):
                if sub.text.strip():
                    translated_text = translate_text_with_retry(translator, sub.text)
                    sub.text = translated_text
                
                if progress_callback and i % 10 == 0:
                    progress_callback(f"üìù {filename}: {i+1}/{total_subs} d√≤ng")
                
                if i % 10 == 0:
                    time.sleep(0.5)  # Tr√°nh rate limit
        else:
            # D·ªãch batch
            batch_size = 20
            texts_to_translate = []
            text_mapping = {}
            
            for i, sub in enumerate(subs):
                if sub.text.strip():
                    texts_to_translate.append(sub.text)
                    text_mapping[sub.text] = i
            
            translated_texts = {}
            
            for i in range(0, len(texts_to_translate), batch_size):
                batch = texts_to_translate[i:i+batch_size]
                
                for text in batch:
                    translated = translate_text_with_retry(translator, text)
                    translated_texts[text] = translated
                    time.sleep(0.3)
                
                if progress_callback:
                    progress_callback(f"üöÄ {filename}: batch {i//batch_size + 1}/{(len(texts_to_translate)-1)//batch_size + 1}")
            
            # √Åp d·ª•ng b·∫£n d·ªãch
            for sub in subs:
                if sub.text.strip() and sub.text in translated_texts:
                    sub.text = translated_texts[sub.text]
        
        result = srt_to_string(subs)
        
        if progress_callback:
            progress_callback(f"‚úÖ Ho√†n th√†nh {filename}")
        
        return {
            'filename': filename,
            'content': result,
            'status': 'success',
            'subtitle_count': total_subs
        }
        
    except Exception as e:
        if progress_callback:
            progress_callback(f"‚ùå L·ªói {filename}: {str(e)}")
        
        return {
            'filename': filename,
            'content': None,
            'status': 'error',
            'error': str(e)
        }

def create_zip_file(translated_files):
    """T·∫°o file ZIP ch·ª©a c√°c file ƒë√£ d·ªãch"""
    zip_buffer = io.BytesIO()
    
    with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
        for file_info in translated_files:
            if file_info['status'] == 'success':
                # T·∫°o t√™n file m·ªõi
                original_name = file_info['filename']
                name_without_ext = os.path.splitext(original_name)[0]
                new_filename = f"{name_without_ext}_vietnamese.srt"
                
                # Th√™m v√†o ZIP
                zip_file.writestr(new_filename, file_info['content'])
    
    zip_buffer.seek(0)
    return zip_buffer.getvalue()

def display_translation_progress(files_count):
    """Hi·ªÉn th·ªã thanh ti·∫øn tr√¨nh cho vi·ªác d·ªãch nhi·ªÅu file"""
    progress_bar = st.progress(0)
    status_text = st.empty()
    
    return progress_bar, status_text

def display_srt_preview(srt_content, filename=""):
    """Hi·ªÉn th·ªã preview c·ªßa file SRT"""
    try:
        subs = pysrt.from_string(srt_content)
        
        st.subheader(f"üì∫ Xem tr∆∞·ªõc: {filename}")
        
        col1, col2, col3 = st.columns(3)
        with col1:
            st.metric("T·ªïng s·ªë d√≤ng", len(subs))
        with col2:
            if subs:
                total_duration = subs[-1].end - subs[0].start
                st.metric("Th·ªùi l∆∞·ª£ng", f"{total_duration}")
            else:
                st.metric("Th·ªùi l∆∞·ª£ng", "N/A")
        with col3:
            total_chars = sum(len(sub.text) for sub in subs)
            st.metric("T·ªïng k√Ω t·ª±", f"{total_chars:,}")
        
        # Hi·ªÉn th·ªã 10 d√≤ng ƒë·∫ßu
        display_subs = subs[:10]
        if len(subs) > 10:
            st.info(f"Hi·ªÉn th·ªã 10/{len(subs)} d√≤ng ƒë·∫ßu ti√™n")
        
        for i, sub in enumerate(display_subs):
            with st.expander(f"D√≤ng {i+1}: {sub.start} --> {sub.end}"):
                st.write(sub.text)
        
    except Exception as e:
        st.error(f"‚ùå L·ªói khi hi·ªÉn th·ªã preview: {str(e)}")

def main():
    st.set_page_config(
        page_title="SRT Translator Pro - Multi Files",
        page_icon="üåê",
        layout="wide"
    )
    
    st.title("üåê SRT Translator Pro - D·ªãch nhi·ªÅu file")
    st.markdown("---")
    
    # Sidebar
    with st.sidebar:
        st.header("‚öôÔ∏è C√†i ƒë·∫∑t")
        
        translation_method = st.radio(
            "Ph∆∞∆°ng ph√°p d·ªãch:",
            ["An to√†n (t·ª´ng d√≤ng)", "Nhanh (batch)"],
            help="An to√†n: ch·∫≠m h∆°n nh∆∞ng √≠t l·ªói. Nhanh: nhanh h∆°n nh∆∞ng c√≥ th·ªÉ b·ªã l·ªói"
        )
        
        st.markdown("---")
        st.header("üÜï T√≠nh nƒÉng m·ªõi")
        st.write("‚Ä¢ ‚úÖ T·∫£i l√™n nhi·ªÅu file c√πng l√∫c")
        st.write("‚Ä¢ ‚úÖ D·ªãch nhi·ªÅu file song song")
        st.write("‚Ä¢ ‚úÖ T·∫£i xu·ªëng file ZIP")
        st.write("‚Ä¢ ‚úÖ Xem tr∆∞·ªõc t·ª´ng file")
        
        st.markdown("---")
        st.header("‚ÑπÔ∏è Th√¥ng tin")
        st.write("‚Ä¢ H·ªó tr·ª£ file SRT kh√¥ng gi·ªõi h·∫°n")
        st.write("‚Ä¢ X·ª≠ l√Ω th√¥ng minh cho file l·ªõn")
        st.write("‚Ä¢ Progress tracking chi ti·∫øt")
    
    # File uploader - cho ph√©p nhi·ªÅu file
    uploaded_files = st.file_uploader(
        "üìÅ Ch·ªçn c√°c file SRT c·∫ßn d·ªãch:",
        type=['srt'],
        accept_multiple_files=True,
        help="C√≥ th·ªÉ ch·ªçn nhi·ªÅu file SRT c√πng l√∫c"
    )
    
    if uploaded_files:
        st.success(f"‚úÖ ƒê√£ t·∫£i {len(uploaded_files)} file(s)")
        
        # Hi·ªÉn th·ªã th√¥ng tin c√°c file
        st.subheader("üìã Danh s√°ch file:")
        
        total_size = 0
        total_subs = 0
        
        file_info_list = []
        
        for i, uploaded_file in enumerate(uploaded_files):
            try:
                # ƒê·ªçc file
                try:
                    srt_content = uploaded_file.read().decode('utf-8')
                except UnicodeDecodeError:
                    try:
                        uploaded_file.seek(0)
                        srt_content = uploaded_file.read().decode('utf-8-sig')
                    except:
                        uploaded_file.seek(0)
                        srt_content = uploaded_file.read().decode('latin-1')
                
                # Parse ƒë·ªÉ l·∫•y th√¥ng tin
                subs = pysrt.from_string(srt_content)
                file_size = len(srt_content)
                
                file_info = {
                    'name': uploaded_file.name,
                    'content': srt_content,
                    'size': file_size,
                    'subtitle_count': len(subs)
                }
                file_info_list.append(file_info)
                
                total_size += file_size
                total_subs += len(subs)
                
                # Hi·ªÉn th·ªã th√¥ng tin file
                with st.expander(f"üìÑ {uploaded_file.name}"):
                    col1, col2, col3 = st.columns(3)
                    with col1:
                        st.metric("S·ªë d√≤ng", len(subs))
                    with col2:
                        st.metric("K√≠ch th∆∞·ªõc", f"{file_size:,} k√Ω t·ª±")
                    with col3:
                        if subs:
                            duration = subs[-1].end - subs[0].start
                            st.metric("Th·ªùi l∆∞·ª£ng", str(duration))
                
            except Exception as e:
                st.error(f"‚ùå L·ªói ƒë·ªçc file {uploaded_file.name}: {str(e)}")
        
        # Th·ªëng k√™ t·ªïng
        st.markdown("---")
        col1, col2, col3, col4 = st.columns(4)
        with col1:
            st.metric("T·ªïng file", len(file_info_list))
        with col2:
            st.metric("T·ªïng d√≤ng ph·ª• ƒë·ªÅ", f"{total_subs:,}")
        with col3:
            st.metric("T·ªïng k√≠ch th∆∞·ªõc", f"{total_size:,} k√Ω t·ª±")
        with col4:
            estimated_time = total_subs * 0.5  # ∆Ø·ªõc t√≠nh 0.5s/d√≤ng
            st.metric("Th·ªùi gian ∆∞·ªõc t√≠nh", f"{estimated_time/60:.1f} ph√∫t")
        
        # C·∫£nh b√°o
        if total_size > 50000:
            st.warning("‚ö†Ô∏è T·ªïng k√≠ch th∆∞·ªõc file kh√° l·ªõn. Qu√° tr√¨nh d·ªãch c√≥ th·ªÉ m·∫•t nhi·ªÅu th·ªùi gian!")
        
        # N√∫t d·ªãch
        if st.button("üöÄ B·∫Øt ƒë·∫ßu d·ªãch t·∫•t c·∫£ file", type="primary"):
            start_time = time.time()
            
            # T·∫°o progress tracking
            progress_container = st.container()
            with progress_container:
                overall_progress = st.progress(0)
                status_text = st.empty()
                detailed_status = st.empty()
            
            translated_files = []
            
            # D·ªãch t·ª´ng file
            for i, file_info in enumerate(file_info_list):
                status_text.text(f"üîÑ ƒêang d·ªãch file {i+1}/{len(file_info_list)}: {file_info['name']}")
                
                def progress_callback(message):
                    detailed_status.text(message)
                
                # D·ªãch file
                result = translate_single_file(
                    file_info['content'], 
                    file_info['name'], 
                    translation_method,
                    progress_callback
                )
                
                translated_files.append(result)
                
                # C·∫≠p nh·∫≠t progress
                overall_progress.progress((i + 1) / len(file_info_list))
                
                # Ngh·ªâ gi·ªØa c√°c file
                time.sleep(1)
            
            end_time = time.time()
            duration = end_time - start_time
            
            # L∆∞u k·∫øt qu·∫£ v√†o session state
            st.session_state.translated_files = translated_files
            st.session_state.translation_completed = True
            
            # Hi·ªÉn th·ªã k·∫øt qu·∫£
            success_count = sum(1 for f in translated_files if f['status'] == 'success')
            error_count = len(translated_files) - success_count
            
            if success_count > 0:
                st.success(f"üéâ D·ªãch ho√†n th√†nh! {success_count}/{len(translated_files)} file th√†nh c√¥ng trong {duration:.1f} gi√¢y")
            
            if error_count > 0:
                st.error(f"‚ùå {error_count} file g·∫∑p l·ªói")
                
                # Hi·ªÉn th·ªã chi ti·∫øt l·ªói
                with st.expander("Chi ti·∫øt l·ªói:"):
                    for file_result in translated_files:
                        if file_result['status'] == 'error':
                            st.write(f"‚Ä¢ {file_result['filename']}: {file_result.get('error', 'Unknown error')}")
        
        # Hi·ªÉn th·ªã t√πy ch·ªçn sau khi d·ªãch
        if st.session_state.get('translation_completed', False):
            st.markdown("---")
            st.subheader("üéØ T√πy ch·ªçn sau khi d·ªãch:")
            
            translated_files = st.session_state.get('translated_files', [])
            success_files = [f for f in translated_files if f['status'] == 'success']
            
            if success_files:
                col1, col2 = st.columns(2)
                
                with col1:
                    if st.button("üëÅÔ∏è Xem tr∆∞·ªõc c√°c file", use_container_width=True):
                        st.session_state.show_preview = True
                
                with col2:
                    # T·∫°o ZIP file
                    zip_data = create_zip_file(success_files)
                    
                    st.download_button(
                        label=f"üíæ T·∫£i xu·ªëng {len(success_files)} file (.zip)",
                        data=zip_data,
                        file_name=f"translated_srt_files_{datetime.now().strftime('%Y%m%d_%H%M%S')}.zip",
                        mime="application/zip",
                        use_container_width=True
                    )
                
                # T·∫£i xu·ªëng t·ª´ng file ri√™ng l·∫ª
                st.subheader("üì• T·∫£i xu·ªëng t·ª´ng file:")
                
                cols = st.columns(min(3, len(success_files)))
                for i, file_result in enumerate(success_files):
                    col_idx = i % len(cols)
                    with cols[col_idx]:
                        original_name = file_result['filename']
                        name_without_ext = os.path.splitext(original_name)[0]
                        new_filename = f"{name_without_ext}_vietnamese.srt"
                        
                        st.download_button(
                            label=f"üìÑ {original_name}",
                            data=file_result['content'],
                            file_name=new_filename,
                            mime="text/plain",
                            use_container_width=True
                        )
                
                # Hi·ªÉn th·ªã preview n·∫øu ƒë∆∞·ª£c y√™u c·∫ßu
                if st.session_state.get('show_preview', False):
                    st.markdown("---")
                    
                    # Ch·ªçn file ƒë·ªÉ preview
                    selected_file = st.selectbox(
                        "Ch·ªçn file ƒë·ªÉ xem tr∆∞·ªõc:",
                        options=range(len(success_files)),
                        format_func=lambda x: success_files[x]['filename']
                    )
                    
                    if selected_file is not None:
                        file_to_preview = success_files[selected_file]
                        display_srt_preview(file_to_preview['content'], file_to_preview['filename'])
    
    else:
        st.info("üëÜ Vui l√≤ng ch·ªçn c√°c file SRT ƒë·ªÉ b·∫Øt ƒë·∫ßu")
        
        # Reset session state
        if 'translated_files' in st.session_state:
            del st.session_state.translated_files
        if 'translation_completed' in st.session_state:
            del st.session_state.translation_completed
        if 'show_preview' in st.session_state:
            del st.session_state.show_preview
        
        # H∆∞·ªõng d·∫´n
        with st.expander("üìö H∆∞·ªõng d·∫´n s·ª≠ d·ª•ng - Phi√™n b·∫£n nhi·ªÅu file"):
            st.markdown("""
            ### üîß C√°ch s·ª≠ d·ª•ng:
            
            1. **Ch·ªçn nhi·ªÅu file SRT** c√πng l√∫c (Ctrl+Click ho·∫∑c Shift+Click)
            2. **Xem th√¥ng tin** c√°c file ƒë√£ ch·ªçn
            3. **Ch·ªçn ph∆∞∆°ng ph√°p d·ªãch** ph√π h·ª£p
            4. **Nh·∫•n "B·∫Øt ƒë·∫ßu d·ªãch"** v√† ch·ªù ƒë·ª£i
            5. **T·∫£i xu·ªëng file ZIP** ho·∫∑c t·ª´ng file ri√™ng l·∫ª
            
            ### üÜï T√≠nh nƒÉng m·ªõi:
            - ‚úÖ **Multi-file upload:** Ch·ªçn nhi·ªÅu file c√πng l√∫c
            - ‚úÖ **Batch translation:** D·ªãch nhi·ªÅu file song song  
            - ‚úÖ **ZIP download:** T·∫£i xu·ªëng t·∫•t c·∫£ file trong 1 file ZIP
            - ‚úÖ **Individual download:** T·∫£i xu·ªëng t·ª´ng file ri√™ng
            - ‚úÖ **Preview system:** Xem tr∆∞·ªõc t·ª´ng file ƒë√£ d·ªãch
            - ‚úÖ **Progress tracking:** Theo d√µi ti·∫øn tr√¨nh chi ti·∫øt
            
            ### üí° L∆∞u √Ω:
            - C√†ng nhi·ªÅu file c√†ng m·∫•t nhi·ªÅu th·ªùi gian
            - Kh√¥ng t·∫Øt trang trong khi d·ªãch
            - Ki·ªÉm tra k·∫øt qu·∫£ tr∆∞·ªõc khi s·ª≠ d·ª•ng
            - File l·ªói s·∫Ω ƒë∆∞·ª£c b√°o c√°o ri√™ng
            """)

if __name__ == "__main__":
    main()
